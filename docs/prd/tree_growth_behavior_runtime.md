# PRD: Механика роста деревьев (Behavior Runtime + ECS Scheduler)

## 1. Problem Statement

Текущая механика деревьев покрывает только рубку. Нужна новая механика роста:
- управляемая через `object defs`;
- совместимая с существующим behavior runtime;
- безопасная для high-load;
- без полного per-tick скана всех объектов.

Ключевое требование: обновлять только действительно растущие деревья. Деревья на финальной стадии не должны получать апдейты.

## 2. Goals

1. Добавить growth-механику деревьев с несколькими стадиями роста.
2. Вынести параметры роста в `object defs` (per-def, без глобальных пресетов).
3. Поддержать оффлайн-рост: при активации чанка догонять прошедшее время.
4. Выполнять догоняющий рост с лимитами, чтобы защищать tick-time.
5. Управлять доступностью действия `chop` через стадии роста.
6. Переключать визуализацию через `flags` (`tree.stage1`, `tree.stage2`, ...).

## 3. Non-Goals

1. Джиттер/рандомизация времени роста.
2. Live-tuning параметров без рестарта.
3. Сезонные/биомные модификаторы (пока не входят в scope).
4. Миграция старых данных (фича новая).
5. Дополнительная telemetry/метрики по growth-пайплайну.

## 4. Product Scope

### 4.1 Growth model

1. Для каждого tree-def задается фиксированный список стадий.
2. Каждая стадия имеет время перехода до следующей в тиках.
3. Рост идет до финальной стадии, после чего полностью останавливается.
4. Рост работает в онлайне и оффлайне:
   - online: обычный тиковый переход;
   - offline: догон при восстановлении/активации чанка.

### 4.2 Stage flags и appearance

1. Runtime выставляет только один stage-флаг дерева:
   - `tree.stage1`, `tree.stage2`, ...
2. `appearance` определяется существующим механизмом `appearance.when.flags`.
3. При переходе стадии обновляется runtime state и flags; appearance пересчитывается существующим ObjectBehaviorSystem.

### 4.3 Доступность рубки по стадиям

1. `chop` доступен не на всех стадиях, а только на явно разрешенных в def.
2. Если стадия неразрешена, действие `chop` не появляется в контекстных действиях.
3. Если рубка разрешена, лут остается полным (logs), без штрафов от стадии.

### 4.4 Catch-up при активации чанка

1. При активации чанка учитывается прошедшее время для дерева.
2. Догон делается с лимитом шагов по росту на объект за проход.
3. Лимит догоняющего роста на объект: `2000` тиков, в конфиг.
4. Если объект полностью не догнан за один проход, он продолжает догоняться дальше через scheduler.
5. Если persisted state дерева в базе отсутствует (генератор карты создал объект без state), дерево считается сразу в максимальной стадии (`growthStageMax`).

## 5. Performance Requirements

1. Никакого глобального обхода всех деревьев на каждом тике.
2. Рост обрабатывается только для due-объектов (у кого наступил `next_growth_tick`).
3. Бюджет обработки due-объектов задается общим лимитом tick-платформы: `game.behavior_tick_global_budget_per_tick`.
4. Для tree growth стартовое значение budget: `200` объектов/тик.
5. Нагрузка рассчитывается от количества загруженных чанков и реально растущих деревьев.
6. Ориентир по данным:
   - до `8000` деревьев в чанке (upper bound);
   - реально растущих ~`30` на чанк.

## 6. Data & Config Requirements

### 6.1 Game config (server)

Добавить параметры:
1. `game.behavior_tick_global_budget_per_tick` (default: `200`)
2. `game.behavior_tick_catchup_limit_ticks` (default: `2000`)

### 6.2 Object defs (per tree def)

Для каждого дерева задаются:
1. количество стадий;
2. длительность переходов между стадиями (в тиках);
3. явный список стадий, где доступна рубка (например, `[2,3,4]`);
4. стартовая стадия для новых объектов (по умолчанию `1`).

### 6.3 Runtime persistent state

Для дерева хранится минимум:
1. `stage` (текущая стадия)
2. `next_growth_tick` (тик следующего перехода)

Состояние сохраняется в `objects.data` и восстанавливается при активации.

Правило восстановления:
1. Если state дерева отсутствует, runtime инициализирует дерево как финальную стадию (`stage = growthStageMax`) без планирования дальнейшего роста.

## 7. Functional Acceptance Criteria

1. Дерево проходит стадии строго по тиковой модели из def.
2. На каждой стадии выставляется корректный флаг `tree.stageN`.
3. Визуальный ресурс меняется через существующие appearance-rules по flags.
4. На финальной стадии дерево больше не планируется на апдейты.
5. `chop` доступен только на стадиях, перечисленных в def.
6. При разрешенной рубке лут полный (logs), независимо от стадии.
7. После рестарта/выгрузки-активации чанка рост догоняет прошедшее время.
8. Догон ограничен `behavior_tick_catchup_limit_ticks` и не ломает tick budget.
9. В обычном режиме нет full-scan по всем деревьям.
10. Budget `behavior_tick_global_budget_per_tick` соблюдается.
11. Если persisted state отсутствует, дерево поднимается как финальная стадия и не попадает в growth schedule.

## 8. Risks

1. Большой оффлайн-лаг может создавать backlog due-объектов.
2. Неправильная конфигурация стадий может приводить к «зависанию» роста.
3. Неверный mapping flags -> appearance может давать неконсистентный визуал.

## 9. Rollout

1. Фича вводится как новая (без миграции существующих данных).
2. Первичный запуск на ограниченном наборе tree-def.
3. После валидации поведения — расширение на остальные деревья.

## 10. Final Decisions

1. Отдельный терминальный флаг `tree.stage_final` не нужен; используется `tree.stageN` последней стадии.
2. Стадии доступности `chop` задаются явным списком (`[2,3,4]`), не диапазоном.
3. При catch-up через несколько стадий применяется только финальное appearance-состояние на момент загрузки.
4. Объект дерева без persisted state считается созданным генератором карты и инициализируется на максимальной стадии роста.

## 11. Behavior Tick Platform Contract (Final)

Деревья — первая механика, которая использует общий централизованный тик-платформенный контракт behavior-обновлений.

1. В behavior contracts добавляется новая tick-capability (рабочее имя: `ScheduledTickBehavior`).
2. Tick-capability опциональна: behavior реализует ее только при необходимости.
3. В registry добавляется fail-fast валидация tick-контракта.
4. Используется единый ECS resource `BehaviorTickSchedule` для всех механик.
5. Частота апдейта задается самим behavior через интервал в тиках (per-def/per-mechanic), а не отдельными per-system scheduler'ами.
6. Scheduler хранит и адресует объекты по `EntityID`.
7. Budget исполнения общий: `global_budget_per_tick`.
8. Catch-up limit общий для всех механик tick-платформы.
9. Системный порядок фиксирован: `BehaviorTickSystem -> MarkObjectBehaviorDirty -> ObjectBehaviorSystem`.
10. Ошибки отдельных объектов не останавливают тик: объект пропускается, ошибка логируется, обработка продолжается.
11. Tick-handler может напрямую изменять ECS компоненты в рамках shard lock и ECS tick.
12. Режим always-tick не поддерживается; behavior обязан задавать интервал в тиках.
13. Приоритизация между behavior-механиками внутри scheduler не вводится.

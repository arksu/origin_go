## План проработки механики загрузки инвентаря игрока из БД

### 1) Цели и требования
- **Цель**: при логине/реаттаче игрока гарантированно получить корректные контейнеры инвентаря в ECS (и при необходимости отправить клиенту снапшот).
- **Требования**:
    - загрузка должна быть **атомарной** на уровне персонажа (либо все контейнеры подняты, либо фейл и безопасный fallback);
    - данные из БД могут быть **устаревшими/повреждёнными** → нужна санация;
    - **валидировать** предметы по itemdefs (type_id, размеры, stack max, allowed placements);
    - обеспечить **детерминизм**: одинаковые данные БД → одинаковый результат ECS;
    - учитывать сценарий **reconnect/reattach**: если сущность уже в ECS, контейнеры не должны дублироваться.

---

### 2) Модель данных в БД: что должно храниться
Минимально для каждого контейнера игрока:
- `owner_id` (character id)
- `kind`, `inventory_key`
- `width/height` (для grid)
- `data` (JSON) со списком предметов и их полей:
    - `item_id` (instance uid) сквозной ид, как entity_id, используем один глобальный id generator
    - `type_id` - item def id
    - `quality`, `quantity`, `data`
    - позиция (`x,y`) для grid или `equip_slot` для equipment

**Важно заранее зафиксировать JSON-схему** (версионирование):
- добавить в `data` поле `v` (версия формата), чтобы можно было мигрировать без боли.

---

### 3) Где в жизненном цикле игрока грузить инвентарь
Развести два сценария:

#### 3.1 Normal spawn (новая сущность в ECS)
Пайплайн:
1) DB: загрузить персонажа (уже делается)
2) DB: загрузить **все инвентари персонажа** одним запросом
3) ECS: при создании player entity — добавить:
    - `InventoryOwner` (ссылки на контейнеры)
    - entity-контейнеры с `InventoryContainer` (на каждого kind/key)
4) После успешного входа: отправить клиенту снапшоты нужных контейнеров (см. раздел 8).

#### 3.2 Reattach (сущность уже существует в ECS)
- Не загружать инвентарь из БД автоматически, чтобы не перетереть “живое” состояние.
- Варианты:
    - **вариант A (рекоменд.)**: при detach персонаж остаётся в ECS → инвентарь остаётся, на reattach ничего не делаем.

---

### 4) API/интерфейсы сервиса загрузки
Сформировать сервис (уровень game/persistence integration):

**`LoadPlayerInventories(characterID) -> []ContainerRecord`**
- обращается к репозиторию и возвращает записи по контейнерам

**`BuildInventoryECS(world, playerHandle, characterID, records) -> result`**
- создаёт/обновляет ECS-структуры, возвращает:
    - список созданных container handles
    - список предупреждений/ошибок санации
    - “снапшоты” для отправки клиенту (опционально)

---

### 5) Запросы к БД и конкурентность
#### 5.1 Чтение
- При логине достаточно **консистентного чтения** в рамках транзакции логина.
- Если используется `FOR UPDATE` на character (у вас есть), можно:
    - в той же транзакции прочитать инвентари, чтобы получить согласованный срез.

#### 5.2 Защита от гонок
- На время сессии игрока записи inventory будут изменяться (move/drop/craft).
- Для загрузки при логине достаточно “на момент логина”.
- Важно: после загрузки и входа любые изменения должны идти через runtime-механику и попадать в сохранение.

---

### 6) Санация/валидация данных из БД
Сделать отдельный этап “sanitize”, который превращает DB JSON → безопасное ECS-состояние.

Проверки:
- **Контейнер**:
    - kind/key валидны
    - для grid: width/height в допустимых пределах
- **Предмет**:
    - `type_id` существует в itemdefs (иначе: удалить/заменить на placeholder/в спец-контейнер “lost&found”)
    - размеры `w/h` соответствуют itemdefs (или пересчитать из itemdefs и игнорировать сохранённые)
    - `quantity`:
        - >0
        - не превышает max stack (обрезать/разбить на несколько стаков — решение за дизайном)
    - допустимость размещения:
        - grid: allowed.grid
        - hand: allowed.hand
        - equipment: slot ∈ allowed.equipmentSlots
- **Коллизии**:
    - grid: предметы не должны пересекаться и выходить за bounds
    - equipment: уникальность слота
    - hand: не более 1 предмета

Политики при проблемах (заранее выбрать и зафиксировать):
- **Lenient (рекоменд.)**: грузим всё возможное, проблемные предметы:
    - переносим в “резервный контейнер/почту” (если есть), В "lost & found" контейнер GRID key=9999 (создается на игрока по необходимости), безразмерный, используется только для хранения (и разбора спорных ситуаций), никогда не будет показан на ui, поэтому не важно как туда складывать (x,y), не важны коллизии предметов, используем как архив.

---

### 7) Восстановление отсутствующих контейнеров (default provisioning)
Нужно определить “базовый набор” контейнеров игрока:
- например:
    - `GRID key=0` (рюкзак)
    - `HAND key=0`
    - `EQUIPMENT key=0`

Если в БД контейнера нет:
- создать контейнер по умолчанию (пустой) и пометить на сохранение.
- если контейнеров несколько (несколько grid по key) — правила генерации ключей и их список должны быть определены конфигом/данными персонажа.

---

### 8) Отправка состояния клиенту при входе
После успешного spawn/reattach:

- Вариант 1 (простой): сразу после `EnterWorld` отправить `S2C_InventoryUpdate` со всеми контейнерами игрока (hand/equipment + основные grid).

Пока у вас есть только `S2C_InventoryUpdate`/`ContainerOpened`, поэтому:
- **рекомендация**: отправить игроку `S2C_InventoryUpdate(updated=[...все его контейнеры...])` один раз на входе.

---

### 9) Связь с сохранением и ревизиями
Чтобы optimistic concurrency работал после загрузки:
- `InventoryContainer.version` должен быть определённо инициализирован:
    - либо `0` при загрузке,
    - либо вычисляемый hash/версия из БД,
    - либо отдельное поле в БД (лучше в перспективе).

**План**:
1) На первом этапе: `version` читаем из базы при создании/загрузке.
2) При любых runtime-операциях: `version++`.
3) При сохранении: сохраняем version в БД, оптимистичная блокировка по полу version

---

### 10) Ошибки, ретраи, таймауты
- Если чтение инвентаря из БД не удалось:
    - не пускать в мир (лучше, чем пустой инвентарь и дюпы), вернуть `ERROR_CODE_INTERNAL_ERROR`.
- Если JSON повреждён:
    - грузить “пустые дефолтные контейнеры” + логировать “corrupted inventory data” (и опционально пометить аккаунт/персонажа флагом для админа).

---

### 11) Тест-план
#### 11.1 Unit
- parse JSON v1 → internal container state
- sanitize:
    - пересечения в grid
    - stack overflow
    - неизвестный type_id
    - неверные размеры
    - несколько предметов в hand
    - дубликаты equip slot

#### 11.2 Интеграционные
- логин → инвентарь поднялся в ECS, клиент получил снапшот
- reattach → инвентарь не дублируется
- отсутствие контейнеров в БД → дефолтные созданы и сохранены позже

---

### 12) Итерации внедрения
1) **Определить JSON формат `inventory.data` + версию `v`** и реализовать парсер.
2) **Load + sanitize + default provisioning** (без авто-реаранжа; просто отбрасывать плохие предметы).
3) **Интеграция в spawn flow**: после спавна сущности добавить контейнеры и отправить снапшот.
4) **Метрики и логи**: количество удалённых/исправленных предметов, ошибки парсинга.
6) Выделение “lost&found” контейнера или почты.

---


## ТЗ: “DisconnectDelay / Detached mode” — сохранение сущности игрока в мире после дисконнекта и ре‑attach при реконнекте

### 1) Контекст и цель
**Проблема:** игроки могут избегать PvP и других игровых механик, выполняя дисконнект в невыгодный момент.  
**Цель фичи:** после потери соединения **оставлять персонажа в мире** на время `GameConfig.DisconnectDelay` секунд в состоянии **detached** (клиента нет, сущность есть и продолжает участвовать в мире), а при повторном подключении — **переиспользовать существующую сущность** (если она ещё жива) и выполнить `attach` клиента к ней.

---

### 2) Термины и определения
- **Client** — сетевое соединение/сессия.
- **CharacterID / EntityID** — стабильный идентификатор персонажа.
- **ECS entity** — игровая сущность в ECS World.
- **Attached** — у сущности есть активный сетевой клиент, ей отправляются события/снапшоты, принимаются команды.
- **Detached** — сущность существует в ECS и в мире (коллизии, урон, видимость и т.п.), но **не имеет активного клиента**; входящие команды отсутствуют, исходящие сетевые события не отправляются (или буферизуются по отдельному решению).
- **DisconnectDelay** — время удержания сущности после дисконнекта (секунды).

---

### 3) Конфигурация
- Использовать существующий параметр: `GameConfig.DisconnectDelay` (секунды).
- Требование: при значении `0` — поведение как раньше (немедленная обработка “как сейчас”: сущность удаляется/уходит из мира).

---

### 4) Требуемое поведение

#### 4.1 Дисконнект (потеря соединения)
**Если клиент был авторизован и находился в мире:**
1. Клиент переводится в состояние “не в мире” (**network-level**), но **сущность НЕ удаляется** из ECS немедленно.
2. Персонаж/сущность переводится в состояние **detached**.
3. Запускается таймер “detached TTL” на `DisconnectDelay` секунд.
4. По истечении TTL, если reattach не произошёл:
    - сущность удаляется из мира штатно (как “logout” / “despawn”), включая корректное удаление из AOI/ChunkManager/Visibility.
    - персонаж в БД помечается offline (как и сейчас).

**Если клиент не был авторизован/не имел персонажа:**
- поведение без изменений (просто закрыть соединение).

#### 4.2 Реконнект (повторный вход)
При успешной аутентификации клиента для `CharacterID`:
1. Определить shard/layer, в котором должен находиться персонаж (как в текущем флоу).
2. **Перед спавном/созданием новой сущности** выполнить поиск существующей сущности персонажа в ECS (по `EntityID`).
3. Если сущность найдена и **ещё жива**:
    - выполнить `attach` клиента к найденной сущности;
    - отменить/сбросить таймер удаления по `DisconnectDelay`;
    - восстановить сетевое состояние: подписки/видимость/снапшот игроку, актуальная позиция, окружающие объекты.
4. Если сущность не найдена (TTL истёк или сущность уже удалена):
    - выполняется стандартный путь входа: подготовка AOI и spawn/enter world.

---

### 5) Состояния и переходы (FSM)
Для персонажа (логически, независимо от реализации):
- **Offline** → (login) → **Attached**
- **Attached** → (disconnect) → **Detached (TTL running)**
- **Detached** → (reconnect before TTL) → **Attached**
- **Detached** → (TTL expired) → **Offline (despawn)**

---

### 6) Правила для detached-сущности
В detached режиме сущность должна:
- оставаться в ECS и в Chunk/AOI регистрации;
- продолжать участвовать в системах мира (движение, коллизии, получение урона, видимость для других, взаимодействия “со стороны других игроков”);
- **не принимать входящие команды** (их нет, т.к. клиента нет);
- иметь консистентную сетевую репликацию для **других игроков** (они продолжают “видеть” и взаимодействовать с этим персонажем как обычно).

Дополнительные продуктовые правила (уточнить/зафиксировать в реализации):
- что происходит с “автодвижением”, если оно было задано до дисконнекта: останавливать. при дисконнекте надо обновить компонент Movement ClearTarget.
- можно ли атаковать/убить detached игрока - да;
- что происходит с лутом/смертью detached персонажа - все как обычно.

---

### 7) Таймеры, конкуренция и конфликт сессий
1. **Одна активная attached-сессия на CharacterID**:
    - если заходит новый клиент, а старый ещё attached — старый должен быть отключён.
2. Если игрок реконнектится несколько раз в течение TTL:
    - используется одна и та же сущность; таймер корректно отменяется/перезапускается.
3. Если TTL истёк ровно в момент реконнекта:
    - определить приоритет: “побеждает attach, если реконнект начат до фактического despawn”. Нужно зафиксировать критерий (“started auth before deadline”).

---

### 8) Сетевое и игровое поведение при attach
При attach к существующей сущности должны быть выполнены минимальные гарантии:
- клиент получает актуальную позицию/состояние персонажа;
- клиент получает окружение (AOI) согласованно с текущими правилами видимости;
- клиент начинает получать события/репликацию с текущего момента (без необходимости “догонять” прошлые события).

---

### 9) Наблюдаемость и метрики (рекомендуется)
Добавить логирование/метрики:
- `detached_started` (characterID, layer, deadline)
- `detached_reattached` (time_detached, layer)
- `detached_expired_despawn` (time_detached, причина)
- количество detached игроков в шарде
- доля реконнектов, которые попали в reattach vs spawn anew

---

### 10) Нефункциональные требования
- **Производительность:** механизм не должен приводить к росту количества сущностей без контроля. TTL обязателен.
- **Потокобезопасность:** операции attach/detach/despawn должны быть атомарными на уровне шарда/мира (в рамках существующей модели синхронизации проекта).
- **Совместимость:** при `DisconnectDelay=0` поведение идентично текущему.

---

### 11) Критерии приемки (Acceptance Criteria)

1. **Detach при дисконнекте**
    - Дано: игрок в мире, происходит дисконнект.
    - Тогда: персонаж остаётся видимым/взаимодействуемым для других минимум `DisconnectDelay` секунд, и не despawn’ится мгновенно.

2. **Reattach**
    - Дано: игрок дисконнектнулся, затем подключился повторно в течение `DisconnectDelay`.
    - Тогда: используется та же ECS-сущность (позиция/HP/статусы сохраняются), клиент снова управляет персонажем.

3. **TTL-expire**
    - Дано: игрок дисконнектнулся и не вернулся в течение `DisconnectDelay`.
    - Тогда: сущность корректно удаляется из мира и AOI, и персонаж считается offline.

4. **PvP-неуязвимость не появляется**
    - Дано: на detached игрока нападают другие игроки.
    - Тогда: механики боя/урона/коллизий применяются как обычно (в рамках текущей логики игры).

5. **Нет дубликатов**
    - Дано: реконнект в течение TTL.
    - Тогда: в мире нет двух сущностей одного CharacterID.

---

### 12) Открытые вопросы (нужно решить перед разработкой)
1. Как трактовать “detached”: прекращаем движение.
3. Что делать при смене layer/shard (если возможно) во время detached: менять layer/shard нельзя.
4. Приоритет race-condition “TTL истёк vs реконнект”: какое правило выбираем - реконнект побеждает.
5. Считаем ли персонажа “online” в БД в detached период или переводим offline сразу при дисконнекте?  переводим offline сразу при дисконнекте.


### 13) Детали реализации
- используем World поле DetachedEntities, ExpirationTime
- создать систему expire_detached.go (ExpireDetachedSystem), в системе итерировать ExpirationTime мапу. проверять с now. если истекло собирать в отдельный слайс toDelete, за пределами цикла вызывать Despawn из мира и удаление из чанков Spatial Static/Dynamic, см текущую реализаци handleDisconnect; shard.UnregisterEntityAOI(playerEntityID); shard.world.Despawn(playerHandle), delete from ExpirationTime map.
- поправить handleDisconnect в соответствии с новой логикой

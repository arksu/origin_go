**План разработки (для кодинг‑агента)**

**Цели**
1. Ввести универсальную механику “линковки” игрока с объектом, основанную на факте коллизии и явном интенте.
2. Построить открытие контейнеров поверх линковки (контейнер — частный случай), без специальных компонент под контейнеры.
3. Обеспечить строгий auto‑close при любом движении игрока/объекта или смене коллизии.
4. Рассылать обновления инвентаря всем игрокам, кто линкнут к объекту‑контейнеру.
5. игрок может открыть только один объект одновременно, но имеет доступ ко всем вложенным его инвентарям

---

**План работ**

1. **Добавить универсальный ECS‑ресурс LinkState**
    - Хранит текущий линк игрока на объект и обратный индекс игроков по объекту.
    - Линк хранит target handle/id, тип линка (пока Interaction/Container), позиции игрока и объекта на момент линка.
    - Ресурс глобальный, без ECS‑компонентов.
      ECS‑ресурс LinkState:
      LinkedByPlayer[playerID] = Link{TargetHandle, TargetID, LinkType, PlayerX/Y, TargetX/Y, CreatedAt}
      PlayersByTarget[targetID] = set(playerID)
      LinkType пока: LinkTypeInteraction (подойдет для контейнеров/станков/стройки).

2. **Сформировать интент линка через существующие команды**
    - `MoveToEntity auto_interact=true` → создает PendingInteraction (тип “OpenContainer”).
    - Интент не создает линк сразу, только ожидание коллизии.
    - `C2S_OpenContainer` → разрешен только при link state, если прилинкованы сразу открываем.

3. **Создание линка в AutoInteractSystem**
    - При обработке PendingInteraction:
        - Если CollisionResult.HasCollision и CollidedWith == target → создать линк (разрешая IsPhantom).
        - Открытие контейнера происходит только после успешного линка.
    - Если коллизии нет и игрок не движется — интент можно снять (во избежание зависаний).

4. **Система строгого разрыва линка**
    - Новая ECS система LinkSystem. проход после TransformUpdateSystem:
        - Если позиция игрока изменилась > epsilon от позиции линка → разрыв.
        - Если позиция объекта изменилась > epsilon → разрыв у всех линкнутых.
        - Если CollisionResult показывает смену объекта коллизии → разрыв.
    - Разрыв линка автоматически закрывает контейнер/интеракцию на стороне сервера.

5. **Открытие контейнера поверх линка**
    - Логика открытия/закрытия контейнера переходит на LinkState:
        - При создании линка на контейнерный объект — отправить `S2C_ContainerOpened`.
        - При разрыве линка — отправить `S2C_ContainerClosed`.
    - Контейнер определяется по `InventoryRefIndex` с `owner_id = object.id`, `key=0`.

6. **Push‑обновления инвентаря**
    - После любого inventory‑op:
        - Если среди `UpdatedContainers` есть контейнер объекта, найти всех игроков, линкнутых к этому объекту через LinkState.
        - Разослать им `S2C_InventoryUpdate` с актуальным состоянием контейнера.

7. **Контейнеры объектов: загрузка и персист**
    1. На этапе загрузки чанка из БД (когда получили список object для чанка):
        - Собрать object.id всех объектов чанка.
        - Одним запросом выбрать inventory по owner_id IN (...) и kind=InventoryGrid (и inventory_key=0`), сгруппировать по `owner_id.
    2. Передавать в `ObjectFactory.Build` дополнительную структуру:
        - InventoryDataByOwnerID map[types.EntityID][]InventoryDataV1.
        - Для каждого объекта по его id доставать инвентарь и создавать контейнеры до/во время Build.
    3. Если инвентарь отсутствует
        - Создавать пустой контейнер по object def (если в def есть `components.inventory`).
    4. Регистрация в `InventoryRefIndex`
        - Делать на этапе создания контейнера, чтобы дальше всё работало.

    - Сохранение при деактивации чанка не ломать: используем существующую систему сохранения инвентарей, но обязательно включить object‑owned контейнеры.

---

**Контекст для агента**
- Коллизии доступны через `components.CollisionResult` (есть `HasCollision`, `CollidedWith`, `IsPhantom`).
- Открытие контейнеров сейчас делается через `handleOpenContainer` / `SendContainerOpened`, но без link‑логики.
- Инвентари объектов должны жить в таблице `inventory` с `owner_id = object.id`.
- Объекты могут быть большими, поэтому радиус не используется, только факт коллизии.
- Любое движение игрока/объекта и любая смена коллизии должны закрывать контейнер.
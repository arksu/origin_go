** Server **

- используется ECS для обсчета сущностей
- shard реализует ECS, шард - слой мира (region)
- системы:
    - movement (priority 100):
        - обновляет сущности, имеющие компоненты Position и Velocity; читает MovementTarget и Speed, чтобы задать нужную скорость и направление (по умолчанию 10 ед/с), при достижении цели удаляет MovementTarget и сбрасывает скорость @internal/ecs/systems/movement.go#14-99
        - простое прибавление смещения (vel * dt) выполняется только для сущностей без Collider — иначе перемещение передается в систему столкновений, чтобы избежать «проскальзывания» через препятствия @internal/ecs/systems/movement.go#33-58
        - вспомогательные методы SetTarget/SetFollowTarget/StopMovement управляют компонентами движения и используются сетевыми хэндлерами (например, на клик по карте) для назначения новой цели @internal/ecs/systems/movement.go#101-125 @internal/network/handlers.go#83-122
    - collider (priority 200):
        - после Movement собирает все статичные сущности (Static + Collider) в spatial hash, затем обрабатывает динамические сущности (Position + Velocity + Collider, без Static) и выполняет swept-AABB резолвинг по стенам итеративно, ограничивая число шагов maxCollisionIterations @internal/ecs/systems/collision.go#10-347
        - после статического резолвинга вставляет динамику в отдельный spatial hash и выполняет фазу dynamic-dynamic push-back, чтобы раздвинуть пересекающиеся движущиеся объекты @internal/ecs/systems/collision.go#330-347
        - CollisionSystem хранит события столкновений, которые могут дальше использоваться другими подсистемами; параметры коллайдеров (ширина/высота, маски слоёв) проверяются при подборе кандидатов, что позволяет фильтровать «несовместимые» типы объектов @internal/ecs/systems/collision.go#231-347


** TODO **
- VisibilitySystem, MovementBroadcastSystem, NetworkFlushSystem

- Логика спавна игрока: Shard.SpawnPlayer реализован, включает fallback позиции, создание компонентов, регистрацию игрока @internal/game/spawn.go#34-167. Однако пункт TODO про проверку коллизий с сущностями ещё не реализован (только walkable tiles) @internal/game/spawn.go#83-110.
- Синхронизация состояния с клиентом: инфраструктура пакетов есть (S2CObjectMove @internal/network/pb/packets.pb.go#675-734), но фактической рассылки после тиков не найдено: нет системы, которая бы брала Position и отправляла S2CObjectMove. Нужно дописывать.
- Игровой цикл сервера: в Shard не видно вызова world.Update или глобального тика — отсутствует. Требуется серверный луп, который обновляет ECS и инициирует рассылку (см. правило 4/5).
- Очистка и дисконнект: Shard.RemovePlayer есть, но нет кода, который вызывал бы StopMovement, сохранял финальные координаты или чистил компоненты при выходе. Другие подсистемы не реализованы.



VisibilitySystem (ECS-приоритет: после обновления позиций, до сетевой рассылки)
Компоненты и данные

Требует у сущности компоненты Position и Vision (для игроков/наблюдателей).
У наблюдаемых объектов должны быть Position + Stealth (или дефолтное значение скрытности) + EntityMeta (ID, тип).
VisibilityState хранит два отображения:
visibleEntities map[ecs.Handle]bool — кого игрок видит.
observers map[ecs.Handle]map[ecs.Handle]struct{} — обратный индекс “кто видит данный объект” (поддерживается системой).
Алгоритм на тик

Перед запуском — заполнить spatial hash (можно переиспользовать CollisionGrid либо иметь VisionGrid с более крупными ячейками).
Для каждого игрока с Vision:
Вычислить AABB радиуса обзора (например, круг → вписанный квадрат).
Запросить кандидатов через spatial hash.
Для каждого кандидата:
Проверить реальную дистанцию dist.
Вычислить порог: visionRadius >= dist + stealth.Value.
Если объект новый и проходит проверку → добавить в visibleEntities, в observers[object] и сгенерировать событие ObjectEnter(handleViewer, handleTarget).
Если объект исчез (не прошёл проверку) → убрать из карт и сгенерировать ObjectLeave.
Для статуса “остаётся видимым” никаких событий не генерируем, но состояние фиксируем.
Система складывает события enter/leave в очередь (например, []VisibilityEvent) для сетевого слоя.
Назначение

Гарантирует, что только видимые объекты пойдут в сетевые пакеты, а также обновляет обратные ссылки для MovementBroadcastSystem.
MovementBroadcastSystem (приоритет после VisibilitySystem)
Пререквизиты

Имеет доступ к:
Position (и, по желанию, Velocity для будущих прогнозов).
EntityMeta с EntityID (для пакета).
Обратный индекс наблюдателей observers из VisibilitySystem.
Получает список “грязных” сущностей (чьи позиции изменились). Это можно сделать двумя способами:
Movement/CollisionSystem при обновлении позиции добавляют handle в DirtyPositions.
MovementBroadcastSystem сама хранит previousPosition и сравнивает (дороже).
Шаги на тик

Взять и очистить DirtyPositions.
Для каждого handle:
Получить текущее положение (float → округлить в int для пакета).
Найти всех наблюдателей: observers[handle].
Для каждого наблюдателя сформировать MovementEvent (viewerHandle, entityID, X, Y).
Добавить MovementEvent в очередь NetworkFlushSystem (не отправлять сразу).
Опционально: применить rate limiting (например, если объект не двигался более чем на epsilon, событие не создавать).
Задача

Преобразовать изменения мира в “кто что должен увидеть” без фактической отправки.
NetworkFlushSystem (самый низкий приоритет перед send)
Входные данные

Очереди из других систем:
VisibilityEvents (enter/leave → приводим к S2CObjectAdd/S2CObjectDelete).
MovementEvents (из MovementBroadcastSystem → S2CObjectMove).
Возможные другие события (статус, чат и т.д.).
Структура

На уровне Shard или World поддерживается ClientRouter:
map[ecs.Handle]*network.Client (handle игрока → клиентское соединение).
NetworkFlushSystem должен иметь доступ к маршрутизатору.
Алгоритм

Для каждого типа очереди:
Сгруппировать события по клиенту (чтобы минимизировать количество вызовов SendPacket).
Например, map[*Client][]proto.Message.
Для каждого клиента:
Отправить накопленные пакеты в порядке приоритета (сначала ObjectDelete, затем ObjectAdd, затем ObjectMove, чтобы синхронизация выглядела консистентно).
Вызвать client.SendPacket(type, msg).
Очереди очищаются после отправки.
Можно настроить ограничение пакетов за тик, чтобы не DDOS-ить клиента (оставшиеся события переносятся на следующий тик).
Примечания

Если клиент отключился, перед Flush нужно удалить его из роутера и выбросить его события (или пересобрать под нового наблюдателя).
Поддержка “батчей” (например, S2CWorldState) позволяет отправлять массив движений в одном пакете; NetworkFlushSystem должен уметь как единичные пакеты, так и батчированные, в зависимости от протокола.
Такое разделение обеспечивает:

VisibilitySystem отвечает за корректный набор видимых сущностей.
MovementBroadcastSystem – за генерацию событий о движении только для заинтересованных клиентов, без сетевой логики.
NetworkFlushSystem – за фактическую отправку пакетов и backpressure.
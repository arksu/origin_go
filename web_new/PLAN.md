# План разработки игрового клиента web_new

## Обзор проекта

Новый игровой клиент объединяет:
- **Изометрическую графику** из `web_old` (PixiJS v8, тайлы, объекты, Spine-анимации)
- **Сетевой протокол** из `web` (Protobuf, WebSocket)
- **Современный стек**: Vue 3, TypeScript, Vite, Pinia

---

## Этап 1: Инициализация проекта

### Цель
Создать базовую структуру проекта с настроенными зависимостями.

### Задачи
1. Инициализировать Vite проект с Vue 3 + TypeScript
2. Установить зависимости:
   - `vue@3`, `vue-router@4`, `pinia`
   - `pixi.js@8`
   - `protobufjs`, `protobufjs-cli`
   - `axios`
   - `sass`
3. Настроить TypeScript (`tsconfig.json`)
4. Настроить Vite (`vite.config.ts`)
5. Создать базовую структуру директорий:
   ```
   src/
   ├── api/           # HTTP API для авторизации
   ├── assets/        # Статические ресурсы
   ├── components/    # Vue компоненты
   ├── game/          # Игровая логика (PixiJS)
   ├── network/       # WebSocket и Protobuf
   ├── router/        # Vue Router
   ├── stores/        # Pinia stores
   ├── types/         # TypeScript типы
   ├── utils/         # Утилиты
   └── views/         # Страницы
   ```
6. Добавить npm скрипт для генерации protobuf типов

### Критерии завершения
- [x] Проект запускается командой `npm run dev`
- [x] Пустая страница открывается в браузере без ошибок
- [x] TypeScript компилируется без ошибок

---

## Этап 2: Авторизация и навигация

### Цель
Реализовать страницы авторизации и выбора персонажа с HTTP API.

### Задачи
1. Создать Pinia store для авторизации (`authStore.ts`)
2. Реализовать API клиент (`api/client.ts`, `api/auth.ts`, `api/characters.ts`)
3. Создать Vue компоненты:
   - `LoginView.vue` — страница входа
   - `RegisterView.vue` — страница регистрации
   - `CharactersView.vue` — список персонажей
4. Настроить Vue Router с guards для защищённых маршрутов
5. Добавить базовые UI компоненты (формы, кнопки, спиннер)

### Критерии завершения
- [ ] Пользователь может войти/зарегистрироваться
- [ ] Отображается список персонажей
- [ ] Можно создать нового персонажа
- [ ] Можно выбрать персонажа для входа в игру

---

## Этап 3: Сетевой слой (Protobuf + WebSocket)

### Цель
Реализовать сетевое взаимодействие с игровым сервером.

### Задачи
1. Сгенерировать TypeScript типы из `packets.proto`
2. Создать `network/GameConnection.ts`:
   - Подключение по WebSocket
   - Отправка/приём бинарных сообщений (Protobuf)
   - Авторизация по токену
   - Ping/Pong для поддержания соединения
3. Создать Pinia store для игрового состояния (`gameStore.ts`):
   - Состояние подключения
   - Позиция игрока
   - Чанки карты
   - Игровые объекты
4. Реализовать обработчики серверных сообщений:
   - `S2C_AuthResult`
   - `S2C_PlayerEnterWorld`
   - `S2C_ChunkLoad` / `S2C_ChunkUnload`
   - `S2C_ObjectSpawn` / `S2C_ObjectDespawn` / `S2C_ObjectMove`
   - `S2C_Error`

### Критерии завершения
- [ ] Клиент подключается к серверу
- [ ] Успешная авторизация по токену
- [ ] Получение и хранение чанков карты
- [ ] Получение и хранение игровых объектов
- [ ] Консольный лог всех входящих сообщений

---

## Этап 4: Базовый рендер (PixiJS)

### Цель
Инициализировать PixiJS и отобразить пустую сцену.

### Задачи
1. Создать `game/Render.ts` — основной класс рендера:
   - Инициализация PIXI.Application
   - Контейнеры: `mapContainer`, `objectsContainer`, `uiContainer`
   - Обработка resize
   - Игровой цикл (ticker)
2. Создать Vue компонент `GameView.vue`:
   - Canvas для PixiJS
   - Интеграция с Vue lifecycle
3. Создать `game/Camera.ts`:
   - Позиция камеры (центрирование на игроке)
   - Масштабирование (zoom)
   - Перетаскивание карты

### Критерии завершения
- [ ] Canvas отображается на странице игры
- [ ] PixiJS инициализируется без ошибок
- [ ] Работает изменение размера окна
- [ ] Фон canvas перекрашивается в цвет (для теста)

---

## Этап 5: Изометрическая проекция и константы

### Цель
Портировать систему координат и констант из `web_old`.

### Задачи
1. Создать `game/Tile.ts` с константами:
   - `TILE_SIZE` =  (игровые единицы на тайл), брать из пакета S2C_PlayerEnterWorld coord_per_tile
   - `TEXTURE_WIDTH` = 64, `TEXTURE_HEIGHT` = 32
   - `GRID_SIZE` = (тайлов в гриде), брать из пакета S2C_PlayerEnterWorld chunk_size
   - `FULL_GRID_SIZE` = пересчитать из GRID_SIZE * TILE_SIZE
2. Создать `utils/Point.ts` — класс для работы с координатами
3. Создать `utils/Coord.ts` — тип для координат
4. Реализовать функции конвертации:
   - `coordGame2Screen(x, y)` — игровые → экранные
   - `coordScreen2Game(screenX, screenY)` — экранные → игровые

### Критерии завершения
- [ ] Функции конвертации работают корректно (unit тесты)
- [ ] Клик по canvas возвращает правильные игровые координаты

---

## Этап 6: Рендер тайлов (Grid)

### Цель
Отобразить тайловую карту с изометрической проекцией.

### Задачи
1. Загрузить атласы тайлов (`base.json`, `tiles.json`)
2. Создать `game/TileSet.ts`:
   - Загрузка конфигураций тайлов (ground, borders, corners)
   - Случайный выбор текстуры по координатам
3. Создать `game/Grid.ts`:
   - Построение меша для чанка
   - WebGL шейдеры для оптимизации
   - Автоматические переходы между тайлами (borders/corners)
4. Интегрировать с `gameStore`:
   - При получении `S2C_ChunkLoad` создавать Grid
   - При получении `S2C_ChunkUnload` скрывать Grid
5. Добавить кэширование и удаление старых гридов

### Критерии завершения
- [ ] Тайлы отображаются в изометрической проекции
- [ ] Переходы между типами тайлов плавные
- [ ] Карта прокручивается при движении игрока
- [ ] Производительность: 60 FPS при 9+ видимых чанках

---

## Этап 7: Рендер объектов

### Цель
Отобразить игровые объекты (персонажи, ресурсы, строения).

### Задачи
1. Создать `game/GameObject.ts` — интерфейс игрового объекта
2. Создать `game/ObjectView.ts`:
   - Загрузка спрайтов по `resource` полю
   - Поддержка многослойных объектов (shadows, layers)
   - Интерактивность (клик, hover)
3. Загрузить конфигурацию объектов (`objects.json`)
4. Реализовать Z-сортировку объектов по Y-координате
5. Обработка сообщений:
   - `S2C_ObjectSpawn` → создать ObjectView
   - `S2C_ObjectDespawn` → удалить ObjectView

### Критерии завершения
- [ ] Объекты отображаются на карте
- [ ] Объекты правильно сортируются по глубине
- [ ] Клик по объекту регистрируется

---

## Этап 8: Движение объектов

### Цель
Реализовать плавное движение объектов с интерполяцией.

### Задачи
1. Создать `game/MoveController.ts`:
   - Интерполяция позиции на клиенте
   - Коррекция расхождения с сервером (lerp)
   - Отображение направления движения
2. Обработка `S2C_ObjectMove`:
   - Обновление целевой позиции
   - Вычисление вектора скорости
3. Обновление позиции в игровом цикле (ticker)
4. Визуализация пути движения (debug mode)

### Критерии завершения
- [ ] Объекты плавно перемещаются
- [ ] Нет телепортаций при небольших рассинхронизациях
- [ ] При остановке объект останавливается плавно

---

## Этап 9: Управление игроком

### Цель
Реализовать управление персонажем игрока.

### Задачи
1. Обработка кликов по карте:
   - Конвертация экранных координат в игровые
   - Отправка `C2S_PlayerAction` (MoveTo)
2. Обработка кликов по объектам:
   - Отправка `C2S_PlayerAction` (MoveToEntity, Interact)
3. Обработка модификаторов (Shift, Ctrl, Alt)
4. Камера следует за игроком:
   - Центрирование на позиции игрока
   - Плавное перемещение камеры
5. Перетаскивание карты (средняя кнопка мыши)
6. Масштабирование колёсиком мыши
7. Непрерывное движение при зажатой ЛКМ

### Критерии завершения
- [ ] Клик по карте отправляет команду движения
- [ ] Персонаж движется к указанной точке
- [ ] Камера следует за персонажем
- [ ] Масштабирование работает

---

## Этап 10: Spine анимации

### Цель
Добавить поддержку Spine анимаций для персонажей.

### Задачи
1. Установить `@esotericsoftware/spine-pixi-v8`
2. Расширить `ObjectView.ts`:
   - Загрузка Spine skeleton
   - Управление анимациями (idle, walk)
   - Смена направления (8 направлений)
3. Интеграция с `MoveController`:
   - При движении включать walk анимацию
   - При остановке включать idle анимацию
   - Выбор анимации по направлению

### Критерии завершения
- [ ] Персонажи со Spine отображаются
- [ ] Анимация меняется при движении/остановке
- [ ] Направление анимации соответствует движению

---

## Этап 11: Terrain объекты

### Цель
Добавить генерацию terrain объектов (деревья, кусты, камни).

### Задачи
1. Портировать `TerrainObjects` из `web_old`
2. Загрузить конфигурации terrain (`wald.json`, `heath.json`)
3. При создании Grid генерировать terrain sprites
4. Правильная Z-сортировка terrain с объектами

### Критерии завершения
- [ ] На тайлах леса появляются деревья
- [ ] На тайлах пустоши появляется растительность
- [ ] Terrain правильно сортируется с объектами

---

## Этап 12: Инвентарь (UI)

### Цель
Реализовать базовый UI инвентаря.

### Задачи
1. Создать `stores/inventoryStore.ts`
2. Обработка сообщений:
   - `S2C_InventoryUpdate`
   - `S2C_ContainerOpened` / `S2C_ContainerClosed`
3. Vue компоненты:
   - `Inventory.vue` — сетка инвентаря
   - `ItemSlot.vue` — ячейка
   - `Item.vue` — предмет
   - `Hand.vue` — предмет в руке (курсор)
4. Drag & Drop предметов
5. Отправка `C2S_InventoryOp` при перемещении

### Критерии завершения
- [ ] Инвентарь открывается по Tab
- [ ] Предметы отображаются в ячейках
- [ ] Можно перетаскивать предметы

---

## Этап 13: Контекстное меню

### Цель
Реализовать контекстное меню для объектов.

### Задачи
1. Создать `ContextMenu.vue`
2. При ПКМ по объекту показывать меню
3. Отправка соответствующих action на сервер

### Критерии завершения
- [ ] ПКМ по объекту показывает меню
- [ ] Выбор действия отправляет команду на сервер

---

## Этап 14: Чат

### Цель
Реализовать игровой чат.

### Задачи
1. Создать `Chat.vue` компонент
2. Обработка серверных сообщений чата
3. Отправка сообщений на сервер
4. Горячая клавиша Enter для фокуса

### Критерии завершения
- [ ] Сообщения отображаются в чате
- [ ] Можно отправлять сообщения
- [ ] Enter фокусирует поле ввода

---

## Этап 15: Статус игрока (UI)

### Цель
Отобразить статистику и состояние игрока.

### Задачи
1. Создать `PlayerStats.vue`
2. Отображение:
   - Здоровье
   - Выносливость
   - Голод
3. Создать `DayTime.vue` — время суток

### Критерии завершения
- [ ] Полоски состояния отображаются
- [ ] Значения обновляются при получении данных

---

## Этап 16: Оптимизация и polish

### Цель
Оптимизировать производительность и улучшить UX.

### Задачи
1. Профилирование и оптимизация:
   - Culling невидимых объектов
   - Batching спрайтов
   - Object pooling
2. Обработка ошибок соединения
3. Reconnect логика
4. Loading states
5. Кастомные курсоры
6. Звуки (опционально)

### Критерии завершения
- [ ] 60 FPS на среднем оборудовании
- [ ] Корректная обработка отключений
- [ ] Отсутствие memory leaks

---

## Зависимости между этапами

```
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9
                         ↓
                        10 → 11
                         
3 → 12 → 13
3 → 14
3 → 15
```

- Этапы 1-9 — последовательные, формируют ядро
- Этапы 10-11 — расширение рендера объектов
- Этапы 12-15 — UI, можно делать параллельно после этапа 3
- Этап 16 — финальный

---

## Ресурсы из существующих проектов

### Из `web_old` (адаптировать):
- `game/Render.ts` — основа рендера
- `game/Grid.ts` — рендер тайлов
- `game/Tile.ts` — константы и TileSet
- `game/ObjectView.ts` — отображение объектов
- `game/MoveController.ts` — интерполяция движения
- `util/Point.ts`, `util/Coord.ts` — утилиты координат
- `util/VertexBuffer.ts` — буфер вершин для меша
- `util/random.ts` — детерминированный random
- `assets/` — графические ресурсы

### Из `web` (использовать как есть или адаптировать):
- `network/GameConnection.js` → `.ts` — WebSocket логика
- `proto/packets.js` → regenerate с типами
- `stores/game.js` → `.ts` — game store
- `stores/auth.js` → `.ts` — auth store
- `api/` — HTTP API

### Из `api/proto/packets.proto`:
- Генерация TypeScript типов

---

## Технический стек

| Категория | Технология | Версия |
|-----------|-----------|--------|
| Framework | Vue | 3.x |
| Language | TypeScript | 5.x |
| Build | Vite | 6.x |
| State | Pinia | 2.x |
| Rendering | PixiJS | 8.x |
| Animation | Spine | 4.2.x |
| Protocol | Protobuf | 7.x |
| Styles | SCSS | - |

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: object.sql

package db

import (
	"context"
	"database/sql"
)

const deleteObject = `-- name: DeleteObject :exec
DELETE FROM object WHERE id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteObject, id)
	return err
}

const getObjectByID = `-- name: GetObjectByID :one
SELECT id, region, x, y, layer, heading, grid_x, grid_y, type, quality, hp, create_tick, last_tick, data
FROM object
WHERE id = $1
`

func (q *Queries) GetObjectByID(ctx context.Context, id int64) (Object, error) {
	row := q.db.QueryRowContext(ctx, getObjectByID, id)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.X,
		&i.Y,
		&i.Layer,
		&i.Heading,
		&i.GridX,
		&i.GridY,
		&i.Type,
		&i.Quality,
		&i.Hp,
		&i.CreateTick,
		&i.LastTick,
		&i.Data,
	)
	return i, err
}

const getObjectsByChunk = `-- name: GetObjectsByChunk :many
SELECT id, region, x, y, layer, heading, grid_x, grid_y, type, quality, hp, create_tick, last_tick, data
FROM object
WHERE region = $1
  AND grid_x = $2
  AND grid_y = $3
  AND layer = $4
`

type GetObjectsByChunkParams struct {
	Region int32 `json:"region"`
	GridX  int32 `json:"grid_x"`
	GridY  int32 `json:"grid_y"`
	Layer  int32 `json:"layer"`
}

func (q *Queries) GetObjectsByChunk(ctx context.Context, arg GetObjectsByChunkParams) ([]Object, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByChunk,
		arg.Region,
		arg.GridX,
		arg.GridY,
		arg.Layer,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Object
	for rows.Next() {
		var i Object
		if err := rows.Scan(
			&i.ID,
			&i.Region,
			&i.X,
			&i.Y,
			&i.Layer,
			&i.Heading,
			&i.GridX,
			&i.GridY,
			&i.Type,
			&i.Quality,
			&i.Hp,
			&i.CreateTick,
			&i.LastTick,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveObject = `-- name: SaveObject :exec
INSERT INTO object (id, region, x, y, layer, heading, grid_x, grid_y, type, quality, hp, create_tick, last_tick, data)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
ON CONFLICT (id) DO UPDATE SET
    region = EXCLUDED.region,
    x = EXCLUDED.x,
    y = EXCLUDED.y,
    layer = EXCLUDED.layer,
    heading = EXCLUDED.heading,
    grid_x = EXCLUDED.grid_x,
    grid_y = EXCLUDED.grid_y,
    type = EXCLUDED.type,
    quality = EXCLUDED.quality,
    hp = EXCLUDED.hp,
    last_tick = EXCLUDED.last_tick,
    data = EXCLUDED.data
`

type SaveObjectParams struct {
	ID         int64          `json:"id"`
	Region     int32          `json:"region"`
	X          int32          `json:"x"`
	Y          int32          `json:"y"`
	Layer      int32          `json:"layer"`
	Heading    int16          `json:"heading"`
	GridX      int32          `json:"grid_x"`
	GridY      int32          `json:"grid_y"`
	Type       int32          `json:"type"`
	Quality    int16          `json:"quality"`
	Hp         int32          `json:"hp"`
	CreateTick int64          `json:"create_tick"`
	LastTick   int64          `json:"last_tick"`
	Data       sql.NullString `json:"data"`
}

func (q *Queries) SaveObject(ctx context.Context, arg SaveObjectParams) error {
	_, err := q.db.ExecContext(ctx, saveObject,
		arg.ID,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
		arg.Heading,
		arg.GridX,
		arg.GridY,
		arg.Type,
		arg.Quality,
		arg.Hp,
		arg.CreateTick,
		arg.LastTick,
		arg.Data,
	)
	return err
}

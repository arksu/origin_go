// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunk.sql

package db

import (
	"context"
)

const getChunk = `-- name: GetChunk :one
SELECT region, x, y, layer, last_tick, data
FROM chunk
WHERE region = $1
  AND x = $2
  AND y = $3
  AND layer = $4
`

type GetChunkParams struct {
	Region int32 `json:"region"`
	X      int32 `json:"x"`
	Y      int32 `json:"y"`
	Layer  int32 `json:"layer"`
}

func (q *Queries) GetChunk(ctx context.Context, arg GetChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, getChunk,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
	)
	var i Chunk
	err := row.Scan(
		&i.Region,
		&i.X,
		&i.Y,
		&i.Layer,
		&i.LastTick,
		&i.Data,
	)
	return i, err
}

const getChunksByRegion = `-- name: GetChunksByRegion :many
SELECT region, x, y, layer, last_tick, data
FROM chunk
WHERE region = $1
`

func (q *Queries) GetChunksByRegion(ctx context.Context, region int32) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, getChunksByRegion, region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.Region,
			&i.X,
			&i.Y,
			&i.Layer,
			&i.LastTick,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveChunk = `-- name: SaveChunk :exec
insert into chunk (region, x, y, layer, last_tick, data)
values ($1, $2, $3, $4, $5, $6)
`

type SaveChunkParams struct {
	Region   int32  `json:"region"`
	X        int32  `json:"x"`
	Y        int32  `json:"y"`
	Layer    int32  `json:"layer"`
	LastTick int64  `json:"last_tick"`
	Data     []byte `json:"data"`
}

func (q *Queries) SaveChunk(ctx context.Context, arg SaveChunkParams) error {
	_, err := q.db.ExecContext(ctx, saveChunk,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
		arg.LastTick,
		arg.Data,
	)
	return err
}

const truncateChunks = `-- name: TruncateChunks :exec
TRUNCATE TABLE chunk
`

func (q *Queries) TruncateChunks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateChunks)
	return err
}

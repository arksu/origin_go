// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: object.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const deleteObject = `-- name: DeleteObject :exec
DELETE
FROM object
WHERE id = $1
`

func (q *Queries) DeleteObject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteObject, id)
	return err
}

const deleteObjectsByChunk = `-- name: DeleteObjectsByChunk :exec
UPDATE object
SET deleted_at = NOW()
WHERE region = $1
  AND chunk_x = $2
  AND chunk_y = $3
  AND layer = $4
  AND deleted_at IS NULL
`

type DeleteObjectsByChunkParams struct {
	Region int `json:"region"`
	ChunkX int `json:"chunk_x"`
	ChunkY int `json:"chunk_y"`
	Layer  int `json:"layer"`
}

func (q *Queries) DeleteObjectsByChunk(ctx context.Context, arg DeleteObjectsByChunkParams) error {
	_, err := q.db.ExecContext(ctx, deleteObjectsByChunk,
		arg.Region,
		arg.ChunkX,
		arg.ChunkY,
		arg.Layer,
	)
	return err
}

const getObjectByID = `-- name: GetObjectByID :one
SELECT id, type_id, region, x, y, layer, chunk_x, chunk_y, heading, quality, hp, owner_id, data, created_at, create_tick, last_tick, updated_at, deleted_at
FROM object
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetObjectByID(ctx context.Context, id int64) (Object, error) {
	row := q.db.QueryRowContext(ctx, getObjectByID, id)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Region,
		&i.X,
		&i.Y,
		&i.Layer,
		&i.ChunkX,
		&i.ChunkY,
		&i.Heading,
		&i.Quality,
		&i.Hp,
		&i.OwnerID,
		&i.Data,
		&i.CreatedAt,
		&i.CreateTick,
		&i.LastTick,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getObjectsByChunk = `-- name: GetObjectsByChunk :many
SELECT id, type_id, region, x, y, layer, chunk_x, chunk_y, heading, quality, hp, owner_id, data, created_at, create_tick, last_tick, updated_at, deleted_at
FROM object
WHERE region = $1
  AND chunk_x = $2
  AND chunk_y = $3
  AND layer = $4
  AND deleted_at IS NULL
`

type GetObjectsByChunkParams struct {
	Region int `json:"region"`
	ChunkX int `json:"chunk_x"`
	ChunkY int `json:"chunk_y"`
	Layer  int `json:"layer"`
}

func (q *Queries) GetObjectsByChunk(ctx context.Context, arg GetObjectsByChunkParams) ([]Object, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByChunk,
		arg.Region,
		arg.ChunkX,
		arg.ChunkY,
		arg.Layer,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Object
	for rows.Next() {
		var i Object
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Region,
			&i.X,
			&i.Y,
			&i.Layer,
			&i.ChunkX,
			&i.ChunkY,
			&i.Heading,
			&i.Quality,
			&i.Hp,
			&i.OwnerID,
			&i.Data,
			&i.CreatedAt,
			&i.CreateTick,
			&i.LastTick,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteObjectsByRegion = `-- name: HardDeleteObjectsByRegion :exec
DELETE FROM object WHERE region = $1
`

func (q *Queries) HardDeleteObjectsByRegion(ctx context.Context, region int) error {
	_, err := q.db.ExecContext(ctx, hardDeleteObjectsByRegion, region)
	return err
}

const softDeleteObject = `-- name: SoftDeleteObject :exec
UPDATE object
SET deleted_at = NOW()
WHERE region = $1 AND id = $2
`

type SoftDeleteObjectParams struct {
	Region int   `json:"region"`
	ID     int64 `json:"id"`
}

func (q *Queries) SoftDeleteObject(ctx context.Context, arg SoftDeleteObjectParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteObject, arg.Region, arg.ID)
	return err
}

const truncateObjects = `-- name: TruncateObjects :exec
TRUNCATE TABLE object
`

func (q *Queries) TruncateObjects(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateObjects)
	return err
}

const upsertObject = `-- name: UpsertObject :exec
INSERT INTO object (
    id, type_id, region, x, y, layer, chunk_x, chunk_y,
    heading, quality, hp, owner_id,
    data, create_tick, last_tick, created_at, updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12,
    $13, $14, $15, NOW(), NOW()
)
ON CONFLICT (region, id) DO UPDATE SET
    type_id = EXCLUDED.type_id,
    x = EXCLUDED.x,
    y = EXCLUDED.y,
    layer = EXCLUDED.layer,
    chunk_x = EXCLUDED.chunk_x,
    chunk_y = EXCLUDED.chunk_y,
    heading = EXCLUDED.heading,
    quality = EXCLUDED.quality,
    hp = EXCLUDED.hp,
    owner_id = EXCLUDED.owner_id,
    data = EXCLUDED.data,
    last_tick = EXCLUDED.last_tick,
    deleted_at = NULL,
    updated_at = NOW()
`

type UpsertObjectParams struct {
	ID         int64                 `json:"id"`
	TypeID     int                   `json:"type_id"`
	Region     int                   `json:"region"`
	X          int                   `json:"x"`
	Y          int                   `json:"y"`
	Layer      int                   `json:"layer"`
	ChunkX     int                   `json:"chunk_x"`
	ChunkY     int                   `json:"chunk_y"`
	Heading    sql.NullInt16         `json:"heading"`
	Quality    sql.NullInt16         `json:"quality"`
	Hp         sql.NullInt32         `json:"hp"`
	OwnerID    sql.NullInt64         `json:"owner_id"`
	Data       pqtype.NullRawMessage `json:"data"`
	CreateTick int64                 `json:"create_tick"`
	LastTick   int64                 `json:"last_tick"`
}

func (q *Queries) UpsertObject(ctx context.Context, arg UpsertObjectParams) error {
	_, err := q.db.ExecContext(ctx, upsertObject,
		arg.ID,
		arg.TypeID,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
		arg.ChunkX,
		arg.ChunkY,
		arg.Heading,
		arg.Quality,
		arg.Hp,
		arg.OwnerID,
		arg.Data,
		arg.CreateTick,
		arg.LastTick,
	)
	return err
}

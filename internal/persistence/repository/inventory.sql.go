// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package repository

import (
	"context"
	"encoding/json"

	"github.com/lib/pq"
)

const deleteInventory = `-- name: DeleteInventory :exec
DELETE FROM inventory
WHERE owner_id = $1 AND kind = $2 AND inventory_key = $3
`

type DeleteInventoryParams struct {
	OwnerID      int64 `json:"owner_id"`
	Kind         int16 `json:"kind"`
	InventoryKey int16 `json:"inventory_key"`
}

func (q *Queries) DeleteInventory(ctx context.Context, arg DeleteInventoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteInventory, arg.OwnerID, arg.Kind, arg.InventoryKey)
	return err
}

const getInventoriesByOwner = `-- name: GetInventoriesByOwner :many
SELECT id, owner_id, kind, inventory_key, data, updated_at, version
FROM inventory
WHERE owner_id = $1
ORDER BY kind, inventory_key
`

func (q *Queries) GetInventoriesByOwner(ctx context.Context, ownerID int64) ([]Inventory, error) {
	rows, err := q.db.QueryContext(ctx, getInventoriesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inventory
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Kind,
			&i.InventoryKey,
			&i.Data,
			&i.UpdatedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventory = `-- name: UpdateInventory :exec
UPDATE inventory
SET data = $2, version = $3, updated_at = now()
WHERE owner_id = $1 AND kind = $4 AND inventory_key = $5 AND version = $6
`

type UpdateInventoryParams struct {
	OwnerID      int64           `json:"owner_id"`
	Data         json.RawMessage `json:"data"`
	Version      int             `json:"version"`
	Kind         int16           `json:"kind"`
	InventoryKey int16           `json:"inventory_key"`
	Version_2    int             `json:"version_2"`
}

func (q *Queries) UpdateInventory(ctx context.Context, arg UpdateInventoryParams) error {
	_, err := q.db.ExecContext(ctx, updateInventory,
		arg.OwnerID,
		arg.Data,
		arg.Version,
		arg.Kind,
		arg.InventoryKey,
		arg.Version_2,
	)
	return err
}

const upsertInventories = `-- name: UpsertInventories :exec
INSERT INTO inventory (owner_id, kind, inventory_key, data, version)
SELECT
    unnest($1::bigint[]),
    unnest($2::int[]),
    unnest($3::int[]),
    unnest($4::text[])::jsonb,
    unnest($5::int[])
ON CONFLICT (owner_id, kind, inventory_key)
DO UPDATE SET
    data = EXCLUDED.data,
    version = EXCLUDED.version,
    updated_at = now()
`

type UpsertInventoriesParams struct {
	OwnerIds      []int64  `json:"owner_ids"`
	Kinds         []int    `json:"kinds"`
	InventoryKeys []int    `json:"inventory_keys"`
	Datas         []string `json:"datas"`
	Versions      []int    `json:"versions"`
}

func (q *Queries) UpsertInventories(ctx context.Context, arg UpsertInventoriesParams) error {
	_, err := q.db.ExecContext(ctx, upsertInventories,
		pq.Array(arg.OwnerIds),
		pq.Array(arg.Kinds),
		pq.Array(arg.InventoryKeys),
		pq.Array(arg.Datas),
		pq.Array(arg.Versions),
	)
	return err
}

const upsertInventory = `-- name: UpsertInventory :one
INSERT INTO inventory (owner_id, kind, inventory_key, data, version)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (owner_id, kind, inventory_key)
DO UPDATE SET
    data = EXCLUDED.data,
    version = EXCLUDED.version,
    updated_at = now()
RETURNING id, owner_id, kind, inventory_key, data, updated_at, version
`

type UpsertInventoryParams struct {
	OwnerID      int64           `json:"owner_id"`
	Kind         int16           `json:"kind"`
	InventoryKey int16           `json:"inventory_key"`
	Data         json.RawMessage `json:"data"`
	Version      int             `json:"version"`
}

func (q *Queries) UpsertInventory(ctx context.Context, arg UpsertInventoryParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, upsertInventory,
		arg.OwnerID,
		arg.Kind,
		arg.InventoryKey,
		arg.Data,
		arg.Version,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Kind,
		&i.InventoryKey,
		&i.Data,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chunk.sql

package repository

import (
	"context"
	"database/sql"
)

const deleteChunksByRegion = `-- name: DeleteChunksByRegion :exec
DELETE FROM chunk WHERE region = $1
`

func (q *Queries) DeleteChunksByRegion(ctx context.Context, region int) error {
	_, err := q.db.ExecContext(ctx, deleteChunksByRegion, region)
	return err
}

const getChunk = `-- name: GetChunk :one
SELECT region, x, y, layer, version, last_tick, last_saved_at, tiles_data, entity_count
FROM chunk
WHERE region = $1
  AND x = $2
  AND y = $3
  AND layer = $4
`

type GetChunkParams struct {
	Region int `json:"region"`
	X      int `json:"x"`
	Y      int `json:"y"`
	Layer  int `json:"layer"`
}

func (q *Queries) GetChunk(ctx context.Context, arg GetChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, getChunk,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
	)
	var i Chunk
	err := row.Scan(
		&i.Region,
		&i.X,
		&i.Y,
		&i.Layer,
		&i.Version,
		&i.LastTick,
		&i.LastSavedAt,
		&i.TilesData,
		&i.EntityCount,
	)
	return i, err
}

const getChunksByRegion = `-- name: GetChunksByRegion :many
SELECT region, x, y, layer, version, last_tick, last_saved_at, tiles_data, entity_count
FROM chunk
WHERE region = $1
`

func (q *Queries) GetChunksByRegion(ctx context.Context, region int) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, getChunksByRegion, region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.Region,
			&i.X,
			&i.Y,
			&i.Layer,
			&i.Version,
			&i.LastTick,
			&i.LastSavedAt,
			&i.TilesData,
			&i.EntityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateChunks = `-- name: TruncateChunks :exec
TRUNCATE TABLE chunk
`

func (q *Queries) TruncateChunks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateChunks)
	return err
}

const upsertChunk = `-- name: UpsertChunk :exec
INSERT INTO chunk (region, x, y, layer, tiles_data, last_tick, entity_count, last_saved_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT (region, x, y, layer) DO UPDATE SET
    tiles_data = EXCLUDED.tiles_data,
    last_tick = EXCLUDED.last_tick,
    entity_count = EXCLUDED.entity_count,
    version = chunk.version + 1,
    last_saved_at = NOW()
`

type UpsertChunkParams struct {
	Region      int           `json:"region"`
	X           int           `json:"x"`
	Y           int           `json:"y"`
	Layer       int           `json:"layer"`
	TilesData   []byte        `json:"tiles_data"`
	LastTick    int64         `json:"last_tick"`
	EntityCount sql.NullInt32 `json:"entity_count"`
}

func (q *Queries) UpsertChunk(ctx context.Context, arg UpsertChunkParams) error {
	_, err := q.db.ExecContext(ctx, upsertChunk,
		arg.Region,
		arg.X,
		arg.Y,
		arg.Layer,
		arg.TilesData,
		arg.LastTick,
		arg.EntityCount,
	)
	return err
}
